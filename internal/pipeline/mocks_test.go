// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package pipeline_test

import (
	"context"
	"sync"

	"github.com/couchcryptid/storm-data-etl-service/internal/domain"
	"github.com/couchcryptid/storm-data-etl-service/internal/pipeline"
)

// Ensure, that MessageReaderMock does implement pipeline.MessageReader.
// If this is not the case, regenerate this file with moq.
var _ pipeline.MessageReader = &MessageReaderMock{}

// MessageReaderMock is a mock implementation of pipeline.MessageReader.
//
//	func TestSomethingThatUsesMessageReader(t *testing.T) {
//
//		// make and configure a mocked pipeline.MessageReader
//		mockedMessageReader := &MessageReaderMock{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			ReadMessageFunc: func(ctx context.Context) (domain.RawEvent, error) {
//				panic("mock out the ReadMessage method")
//			},
//		}
//
//		// use mockedMessageReader in code that requires pipeline.MessageReader
//		// and then make assertions.
//
//	}
type MessageReaderMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// ReadMessageFunc mocks the ReadMessage method.
	ReadMessageFunc func(ctx context.Context) (domain.RawEvent, error)

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// ReadMessage holds details about calls to the ReadMessage method.
		ReadMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockClose       sync.RWMutex
	lockReadMessage sync.RWMutex
}

// Close calls CloseFunc.
func (mock *MessageReaderMock) Close() error {
	if mock.CloseFunc == nil {
		panic("MessageReaderMock.CloseFunc: method is nil but MessageReader.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedMessageReader.CloseCalls())
func (mock *MessageReaderMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// ReadMessage calls ReadMessageFunc.
func (mock *MessageReaderMock) ReadMessage(ctx context.Context) (domain.RawEvent, error) {
	if mock.ReadMessageFunc == nil {
		panic("MessageReaderMock.ReadMessageFunc: method is nil but MessageReader.ReadMessage was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockReadMessage.Lock()
	mock.calls.ReadMessage = append(mock.calls.ReadMessage, callInfo)
	mock.lockReadMessage.Unlock()
	return mock.ReadMessageFunc(ctx)
}

// ReadMessageCalls gets all the calls that were made to ReadMessage.
// Check the length with:
//
//	len(mockedMessageReader.ReadMessageCalls())
func (mock *MessageReaderMock) ReadMessageCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockReadMessage.RLock()
	calls = mock.calls.ReadMessage
	mock.lockReadMessage.RUnlock()
	return calls
}

// Ensure, that MessageWriterMock does implement pipeline.MessageWriter.
// If this is not the case, regenerate this file with moq.
var _ pipeline.MessageWriter = &MessageWriterMock{}

// MessageWriterMock is a mock implementation of pipeline.MessageWriter.
//
//	func TestSomethingThatUsesMessageWriter(t *testing.T) {
//
//		// make and configure a mocked pipeline.MessageWriter
//		mockedMessageWriter := &MessageWriterMock{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			WriteMessageFunc: func(ctx context.Context, event domain.OutputEvent) error {
//				panic("mock out the WriteMessage method")
//			},
//		}
//
//		// use mockedMessageWriter in code that requires pipeline.MessageWriter
//		// and then make assertions.
//
//	}
type MessageWriterMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// WriteMessageFunc mocks the WriteMessage method.
	WriteMessageFunc func(ctx context.Context, event domain.OutputEvent) error

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// WriteMessage holds details about calls to the WriteMessage method.
		WriteMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Event is the event argument value.
			Event domain.OutputEvent
		}
	}
	lockClose        sync.RWMutex
	lockWriteMessage sync.RWMutex
}

// Close calls CloseFunc.
func (mock *MessageWriterMock) Close() error {
	if mock.CloseFunc == nil {
		panic("MessageWriterMock.CloseFunc: method is nil but MessageWriter.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedMessageWriter.CloseCalls())
func (mock *MessageWriterMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// WriteMessage calls WriteMessageFunc.
func (mock *MessageWriterMock) WriteMessage(ctx context.Context, event domain.OutputEvent) error {
	if mock.WriteMessageFunc == nil {
		panic("MessageWriterMock.WriteMessageFunc: method is nil but MessageWriter.WriteMessage was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Event domain.OutputEvent
	}{
		Ctx:   ctx,
		Event: event,
	}
	mock.lockWriteMessage.Lock()
	mock.calls.WriteMessage = append(mock.calls.WriteMessage, callInfo)
	mock.lockWriteMessage.Unlock()
	return mock.WriteMessageFunc(ctx, event)
}

// WriteMessageCalls gets all the calls that were made to WriteMessage.
// Check the length with:
//
//	len(mockedMessageWriter.WriteMessageCalls())
func (mock *MessageWriterMock) WriteMessageCalls() []struct {
	Ctx   context.Context
	Event domain.OutputEvent
} {
	var calls []struct {
		Ctx   context.Context
		Event domain.OutputEvent
	}
	mock.lockWriteMessage.RLock()
	calls = mock.calls.WriteMessage
	mock.lockWriteMessage.RUnlock()
	return calls
}

// Ensure, that ExtractorMock does implement pipeline.Extractor.
// If this is not the case, regenerate this file with moq.
var _ pipeline.Extractor = &ExtractorMock{}

// ExtractorMock is a mock implementation of pipeline.Extractor.
//
//	func TestSomethingThatUsesExtractor(t *testing.T) {
//
//		// make and configure a mocked pipeline.Extractor
//		mockedExtractor := &ExtractorMock{
//			ExtractFunc: func(ctx context.Context) (domain.RawEvent, error) {
//				panic("mock out the Extract method")
//			},
//		}
//
//		// use mockedExtractor in code that requires pipeline.Extractor
//		// and then make assertions.
//
//	}
type ExtractorMock struct {
	// ExtractFunc mocks the Extract method.
	ExtractFunc func(ctx context.Context) (domain.RawEvent, error)

	// calls tracks calls to the methods.
	calls struct {
		// Extract holds details about calls to the Extract method.
		Extract []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockExtract sync.RWMutex
}

// Extract calls ExtractFunc.
func (mock *ExtractorMock) Extract(ctx context.Context) (domain.RawEvent, error) {
	if mock.ExtractFunc == nil {
		panic("ExtractorMock.ExtractFunc: method is nil but Extractor.Extract was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockExtract.Lock()
	mock.calls.Extract = append(mock.calls.Extract, callInfo)
	mock.lockExtract.Unlock()
	return mock.ExtractFunc(ctx)
}

// ExtractCalls gets all the calls that were made to Extract.
// Check the length with:
//
//	len(mockedExtractor.ExtractCalls())
func (mock *ExtractorMock) ExtractCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockExtract.RLock()
	calls = mock.calls.Extract
	mock.lockExtract.RUnlock()
	return calls
}

// Ensure, that TransformerMock does implement pipeline.Transformer.
// If this is not the case, regenerate this file with moq.
var _ pipeline.Transformer = &TransformerMock{}

// TransformerMock is a mock implementation of pipeline.Transformer.
//
//	func TestSomethingThatUsesTransformer(t *testing.T) {
//
//		// make and configure a mocked pipeline.Transformer
//		mockedTransformer := &TransformerMock{
//			TransformFunc: func(ctx context.Context, raw domain.RawEvent) (domain.OutputEvent, error) {
//				panic("mock out the Transform method")
//			},
//		}
//
//		// use mockedTransformer in code that requires pipeline.Transformer
//		// and then make assertions.
//
//	}
type TransformerMock struct {
	// TransformFunc mocks the Transform method.
	TransformFunc func(ctx context.Context, raw domain.RawEvent) (domain.OutputEvent, error)

	// calls tracks calls to the methods.
	calls struct {
		// Transform holds details about calls to the Transform method.
		Transform []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Raw is the raw argument value.
			Raw domain.RawEvent
		}
	}
	lockTransform sync.RWMutex
}

// Transform calls TransformFunc.
func (mock *TransformerMock) Transform(ctx context.Context, raw domain.RawEvent) (domain.OutputEvent, error) {
	if mock.TransformFunc == nil {
		panic("TransformerMock.TransformFunc: method is nil but Transformer.Transform was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Raw domain.RawEvent
	}{
		Ctx: ctx,
		Raw: raw,
	}
	mock.lockTransform.Lock()
	mock.calls.Transform = append(mock.calls.Transform, callInfo)
	mock.lockTransform.Unlock()
	return mock.TransformFunc(ctx, raw)
}

// TransformCalls gets all the calls that were made to Transform.
// Check the length with:
//
//	len(mockedTransformer.TransformCalls())
func (mock *TransformerMock) TransformCalls() []struct {
	Ctx context.Context
	Raw domain.RawEvent
} {
	var calls []struct {
		Ctx context.Context
		Raw domain.RawEvent
	}
	mock.lockTransform.RLock()
	calls = mock.calls.Transform
	mock.lockTransform.RUnlock()
	return calls
}

// Ensure, that LoaderMock does implement pipeline.Loader.
// If this is not the case, regenerate this file with moq.
var _ pipeline.Loader = &LoaderMock{}

// LoaderMock is a mock implementation of pipeline.Loader.
//
//	func TestSomethingThatUsesLoader(t *testing.T) {
//
//		// make and configure a mocked pipeline.Loader
//		mockedLoader := &LoaderMock{
//			LoadFunc: func(ctx context.Context, event domain.OutputEvent) error {
//				panic("mock out the Load method")
//			},
//		}
//
//		// use mockedLoader in code that requires pipeline.Loader
//		// and then make assertions.
//
//	}
type LoaderMock struct {
	// LoadFunc mocks the Load method.
	LoadFunc func(ctx context.Context, event domain.OutputEvent) error

	// calls tracks calls to the methods.
	calls struct {
		// Load holds details about calls to the Load method.
		Load []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Event is the event argument value.
			Event domain.OutputEvent
		}
	}
	lockLoad sync.RWMutex
}

// Load calls LoadFunc.
func (mock *LoaderMock) Load(ctx context.Context, event domain.OutputEvent) error {
	if mock.LoadFunc == nil {
		panic("LoaderMock.LoadFunc: method is nil but Loader.Load was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Event domain.OutputEvent
	}{
		Ctx:   ctx,
		Event: event,
	}
	mock.lockLoad.Lock()
	mock.calls.Load = append(mock.calls.Load, callInfo)
	mock.lockLoad.Unlock()
	return mock.LoadFunc(ctx, event)
}

// LoadCalls gets all the calls that were made to Load.
// Check the length with:
//
//	len(mockedLoader.LoadCalls())
func (mock *LoaderMock) LoadCalls() []struct {
	Ctx   context.Context
	Event domain.OutputEvent
} {
	var calls []struct {
		Ctx   context.Context
		Event domain.OutputEvent
	}
	mock.lockLoad.RLock()
	calls = mock.calls.Load
	mock.lockLoad.RUnlock()
	return calls
}
